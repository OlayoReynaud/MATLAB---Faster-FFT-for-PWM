function pwm_hmncs = get_spectrum(vm, mf, carrier_type, numb_m)
   % get_spectrum computes the spectrum using the new algorithm.
   % WARNING: Notice that this fucntion does not consider the phase of the
   % carrier signal: it is assumed 0 in any case.
   %

   % Arguments:
   %   vm (vector): A vector containing one period of the modulating signal.
   %   mf (int): Frequency modulation index.
   %   carrier_type (int): Specifies the type of carrier 
   %        (1 for symmetric, 2 for leading edge, 3 for trailing edge).
   %   numb_m (int): If passed as argument, the spectrum is computed up to
   %        numb_m regions, if it is not passed, the spectrum is computed
   %        up to Nyquist Frequency, just as a regular FFT.numb_m can be as
   %        high as wanted, not bounded by Nyquist limit).
   %
   % Returns:
   %    pwm_hmncs(vector): A vector of complex values, A_i + j B_i, where 
   %        A_i and B_i are the coefficients (in cosine-sine form) of the
   %        Fourier series of the PWM signal that oscilates between -1 and
   %        1 generated by comparing vm with a triangular carrier with
   %        amplitude 1 and frequency mf*fm (fm is the frequency of
   %        vm).
      
    N = length(vm);    
    n = (N-1)/2; % Total number of harmonics calculated in raw iffts.
                 % Not to be mistaken with n index of baseband
                 % harmonics. Named n to respect the notation of DFT
    samples_in_iffts = ceil(n);
    % position of the regionÂ´s center at ifft results
    center_idx = samples_in_iffts + 1;
    
    % exist('numb_m','var') checks if numb_m was passed as an argument
    if ~exist('numb_m','var')
        % If no number of carrier regions are given, the output spectrum
        % range is the same as the one obtained with regular FFT (i.e
        % up to Nyquist Frequency)
        fft_freqs = true;
        samples_in_spectrum = samples_in_iffts;
        % numb_m in this case is the number of carrier harmonic regions
        % that could possibly affect the spectrum. 
        numb_m = floor(1.5*samples_in_spectrum/mf);
    else
        % The samples within spectrum is the samples until the last carrier
        % harmonic + the right side of that region. 
        fft_freqs = false;
        left_side = round(numb_m*mf);
        right_side = min(left_side, ceil(n) + 1);
        samples_in_spectrum = left_side + right_side;
    end
       
    % --- Basebands---  
    baseband_ifft = ifft(2*vm);
    baseband_hmncs = baseband_ifft(1:samples_in_iffts);    
    % pwm_hmncs only contains the IFFT for basebands now, but the rest will
    % be added to the same vector.
    if fft_freqs
        pwm_hmncs = baseband_hmncs;
    else
        pwm_hmncs = modify_length(baseband_hmncs, samples_in_spectrum);
    end
    
    % --- Sidebands ---  
    for m = 1:numb_m
        % For each m, the left side half of the sideband harmonics are the
        % first N values of the ifft of sideband_func and the right side is
        % the last N values of the ifft. Also, the results must be shifted
        % to belong to its frequencies.
              
        if carrier_type == 1 %"symetric"
            sideband_func = (4/(m*pi))*(sin(m*pi*(1 + vm)/2));
        elseif carrier_type == 2 %  "leading_edge"
            sideband_func = (2*1i/(m*pi))*(cos(m*pi*vm) - ((-1)^m)- ...
                             1i*sin(m*pi*vm));
        elseif carrier_type == 3 %"trailing_edge"
            sideband_func = (2*1i/(m*pi))*(((-1)^m)- cos(m*pi*vm) -...
                             1i*sin(m*pi*vm));
        end
        
        ifft_sideband_func = fftshift(ifft(sideband_func)); % Compute ifft
        
        % Place at the correct indices
        numb_samples_shift = m*mf + 1; % Position of region within spectrum
        numb_samples_diff = center_idx - numb_samples_shift;
        
        if (numb_samples_diff > 0)
            % If the window's center (i.e the carrier harmonic) is within
            % the ifft frequency range. 
            window = ifft_sideband_func(numb_samples_diff + 1:end);
            truncated_vals = ifft_sideband_func(1:numb_samples_diff);
            
            % Harmoncs falling into negative frequencies are flipped and 
            % complex-conjugated.
            negative_frqs_vals = [0, conj(flip(truncated_vals))];
            pwm_hmncs = pwm_hmncs + modify_length(negative_frqs_vals,...
                                                  samples_in_spectrum);
        else
            % If the window's center (i.e the carrier harmonic) is outside
            % the ifft frequency range
            window = [zeros(1, abs(numb_samples_diff)),ifft_sideband_func];            
        end     
        pwm_hmncs = pwm_hmncs + modify_length(window, samples_in_spectrum);
    end
end

function output_vector = modify_length(imput_vector, output_size)
    % Adds zeros to the end of vector if it is to short and truncates it
    % if it is to large. 
    % Imput vectors must be 1-dimentional ROWS. 
    imput_size = length(imput_vector);
    if output_size < imput_size
        output_vector = imput_vector(1:output_size);
    elseif output_size > imput_size
        size_dif = output_size - imput_size;
        output_vector = [imput_vector, zeros(1, size_dif)];
    else
        output_vector = imput_vector;
    end
end