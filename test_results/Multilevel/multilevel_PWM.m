% Parámetros de la modulación multinivel

num_levels = 3; % Número de niveles del inversor
carrier_phase_array = [0,0,0,0]; % Vector conteniendo la fase de cada una de las portadoras, en grados (rango [-180,180])
amp_v_mod_spectra = [0,0.7,0,0.3]; % Módulo de los coeficientes del espectro de la señal moduladora (orden ascendiente según el orden, empezando por DC)
phase_v_mod_spectra = [0,0]; % Fase de los armónicos que componen la señal moduladora
num_samples = 1e3; % Número de puntos de la señal moduladora
mf = 50; % Índice de modulación en frecuencia

%% Generación de la señal moduladora:

x = linspace(0,2 * pi * (1 - 1/num_samples),num_samples);

v_mod = amp_v_mod_spectra(1) * ones(1,num_samples);

for i = 2 : length(amp_v_mod_spectra)
    
    if amp_v_mod_spectra(i) == 0
        continue
    else

        v_mod = v_mod + amp_v_mod_spectra(i) * sin((i - 1) * x);

    end

end

% Se acota su valor al rango [-1,1] para tener en cuenta posible sobremodulación

for i = 1 : num_samples

    if v_mod(i) > 1
        v_mod(i) = 1;
    end

    if v_mod(i) < -1
        v_mod(i) = -1;
    end

end

%% Representación gráfica de las señales

% Generación de señales potadoras:

v_carrier = zeros(2 * num_levels,num_samples);

% for i = 1 : num_levels
%     v_carrier(i,:) = (sawtooth(mf * (x + pi/180 * carrier_phase_array(i)/mf),0.5) + 2 * (i - 1))/num_levels;
% end

for i = 1 : num_levels
    v_carrier(i,:) = (0.5 * sawtooth(mf * (x + pi/180 * carrier_phase_array(i)/mf),0.5) + 0.5 + i - 1)/(num_levels);
end

for i = num_levels + 1 : 2 * num_levels
    v_carrier(i,:) = - v_carrier(i - num_levels,:);
end

% Generación de la señal PWM:

PWM = zeros(1,num_samples);

for i = 1 : num_samples

    for j = 1 : num_levels        
        if v_mod(i) > v_carrier(j,i)

           PWM(i) = PWM(i) + 1/num_levels; 

        end

        if v_mod(i) < v_carrier(j + num_levels,i)

            PWM(i) = PWM(i) - 1/num_levels;

        end
    end

end

% Figura:

Fig = figure;

Fig.Position = [450,250,1e3,400];

subplot(1,2,1)

Plot_mod = plot(x,v_mod);
Plot_mod.Color = 'black';
Plot_mod.LineWidth = 1.2;
xticklabels([])
yticklabels([])

box on
grid on

xlim([0,2*pi])
ylim([-1.2,1.2])

hold on

plot(x,v_carrier,'Color','#909090')

plot(x,PWM,'Color','black')

hold off

%% Cálculo del espectro de la señal PWM mediante FFT

tic

PWM_spectra = 1/num_samples * fft(PWM);

T_FFT = toc;

subplot(1,2,2)

Plot_FFT = plot(abs(PWM_spectra));

hold on

%% Cálculo del espectro de la señal PWM mediante el método de Olayo

% Se genera una moduladora para cada portadora:

v_mod_Olayo = zeros(num_levels,num_samples);

tic

for i = 1 : num_levels
    for j = 1 : num_samples
        if v_mod(j) > i/num_levels
            
            v_mod_Olayo(i,j) = 1;

        elseif v_mod(j) < (i - 1)/num_levels

            v_mod_Olayo(i,j) = - 1;

        else

            v_mod_Olayo(i,j) = 2 * v_mod(j) * num_levels - 2 * i + 1;

        end
    end
end

for i = num_levels + 1 : 2 * num_levels
    for j = 1 : num_samples
        if v_mod(j) < - (i - num_levels)/num_levels
            
            v_mod_Olayo(i,j) = - 1;

        elseif v_mod(j) > - (i - num_levels - 1)/num_levels

            v_mod_Olayo(i,j) = 1;

        else

            v_mod_Olayo(i,j) = 2 * v_mod(j) * num_levels + 2 * (i - num_levels) - 1;

        end
    end
end

% plot(x,v_mod_Olayo)

% Se aplica el método de Olayo a cada par moduladora-portadora:

individual_PWM_spectra_Olayo = zeros(num_levels,num_samples/2);

for i = 1 : num_levels
    individual_PWM_spectra_Olayo(i,:) = fft_for_pwm(v_mod_Olayo(i,:),1/num_levels,0,mf,1,5);
end

for i = num_levels + 1 : 2 * num_levels
    individual_PWM_spectra_Olayo(i,:) = - fft_for_pwm(- v_mod_Olayo(i,:),0,-1/num_levels,mf,1,5);
end

T_Olayo = toc;

% Se suman todas las componentes de la PWM resultante

PWM_spectra_Olayo = sum(individual_PWM_spectra_Olayo);
PWM_spectra_Olayo(1) = 0;

% Se grafica sobre el resultado de la FFT:

plot(0.5 * abs(PWM_spectra_Olayo))

xlim([0,5 * mf])
ylim([0,0.2])
box on
grid on
legend("FFT","Método de Olayo")
fontname("Times New Roman")

function pwm_hmncs = fft_for_pwm(vm, V_dc_up, V_dc_low, mf,...
        carrier_type, numb_m)
   % Returns a vector of complex values, A_i + j B_i, where A_i and B_i are
   % the coefficients (in cosine-sine form) of the Fourier series of the
   % pwm signal that oscilates between V_dc_up and V_dc_low generated by
   % comparing the modulating signal, vm, with a triangular carrier with
   % amplitude 1 and frequency mf times the frequency of vm.
   %
   % vm must be EXACTLY one period of the modulating signal.
   %
   % carrier_type (int) determines the type of triangular wave at
   % carrier. It is either 1 for "symetric", 2 for  "leading_edge" or
   % 3 for "trailing_edge"
   %
   % If numb_m is passed as argument, it computes the spectrum up numb_m
   % regions (numb_m can be as high as wanted, not bounded by Nyquist
   % limit). If numb_m si not passed as argument, the spectrum is computed
   % up to Nyquist Frequency, just as a regular FFT.
   %
   % WARNING: Notice that this fucntion does not consider the phase of the
   % carrier signal: it is assumed 0 in any case.
   
    V_dc = V_dc_up - V_dc_low;    
    N = length(vm);    
    n = (N-1)/2; % Total number of harmonics calculated in raw iffts.
                 % Not to be mistaken with n index of baseband
                 % harmonics. Named n to respect the notation of DFT
    samples_in_iffts = ceil(n);
    % position of the region´s center at ifft results
    center_idx = samples_in_iffts + 1;
    
    % exist('numb_m','var') checks if numb_m was passed as an argument
    if ~exist('numb_m','var')
        % If no number of carrier regions are given, the output spectrum
        % range is the same as the one obtained with regular FFT (i.e
        % up to Nyquist Frequency)
        fft_freqs = true;
        samples_in_spectrum = samples_in_iffts;
        % numb_m in this case is the number of carrier harmonic regions
        % that could possibly affect the spectrum. 
        numb_m = floor(1.5*samples_in_spectrum/mf);
    else
        % The samples within spectrum is the samples until the last carrier
        % harmonic + the right side of that region. 
        fft_freqs = false;
        left_side = round(numb_m*mf);
        right_side = min(left_side, ceil(n) + 1);
        samples_in_spectrum = left_side + right_side;
    end
       
    % --- Basebands---  
    baseband_ifft = ifft(V_dc*vm);    
    baseband_hmncs = baseband_ifft(1:samples_in_iffts);    
    % pwm_hmncs only contains the IFFT for basebands now, but the rest will
    % be added to the same vector.
    if fft_freqs
        pwm_hmncs = baseband_hmncs;
    else
        pwm_hmncs = modify_length(baseband_hmncs, samples_in_spectrum);
    end
    
    % --- DC component ---  
    %  pwm_hmncs(1) is mean(vm)*Vdc. It has to be replaced by 
    % (A_00/2) = V_dc(1 + mean(vm)) + 2*V_dc_low
    pwm_hmncs(1) = V_dc + pwm_hmncs(1) + 2*V_dc_low;

    % --- Sidebands ---  
    for m = 1:numb_m
        % For each m, the left side half of the sideband harmonics are the
        % first N values of the ifft of sideband_func and the right side is
        % the last N values of the ifft. Also, the results must be shifted
        % to belong to its frequencies.
              
        if carrier_type == 1 %"symetric"
            sideband_func = (2*V_dc/(m*pi))*(sin(m*pi*(1 + vm)/2));
        elseif carrier_type == 2 %  "leading_edge"
            sideband_func = (1i*V_dc/(m*pi))*(cos(m*pi*vm) - ((-1)^m)- ...
                             1i*sin(m*pi*vm));
        elseif carrier_type == 3 %"trailing_edge"
            sideband_func = (1i*V_dc/(m*pi))*(((-1)^m)- cos(m*pi*vm) -...
                             1i*sin(m*pi*vm));
        end
        
        ifft_sideband_func = fftshift(ifft(sideband_func)); % Compute ifft
        
        % Place at the correct indices
        numb_samples_shift = m*mf + 1; % Position of region within spectrum
        numb_samples_diff = center_idx - numb_samples_shift;
        
        if (numb_samples_diff > 0)
            % If the window's center (i.e the carrier harmonic) is within
            % the ifft frequency range. 
            window = ifft_sideband_func(numb_samples_diff + 1:end);
            truncated_vals = ifft_sideband_func(1:numb_samples_diff);
            
            % Harmoncs falling into negative frequencies are flipped and 
            % complex-conjugated.
            negative_frqs_vals = [0, conj(flip(truncated_vals))];
            pwm_hmncs = pwm_hmncs + modify_length(negative_frqs_vals,...
                                                  samples_in_spectrum);
        else
            % If the window's center (i.e the carrier harmonic) is outside
            % the ifft frequency range
            window = [zeros(1, abs(numb_samples_diff)),ifft_sideband_func];            
        end     
        pwm_hmncs = pwm_hmncs + modify_length(window, samples_in_spectrum);
    end
end

function output_vector = modify_length(imput_vector, output_size)
    % Adds zeros to the end of vector if it is to short and truncates it
    % if it is to large. 
    % Imput vectors must be 1-dimentional ROWS. 
    imput_size = length(imput_vector);
    if output_size < imput_size
        output_vector = imput_vector(1:output_size);
    elseif output_size > imput_size
        size_dif = output_size - imput_size;
        output_vector = [imput_vector, zeros(1, size_dif)];
    else
        output_vector = imput_vector;
    end
end

